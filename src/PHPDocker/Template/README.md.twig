PHPDocker.io generated environment
==================================

#Add to your project#

  * Unzip the file.
  * Move the `phpdocker` folder into your project. You may rename this folder (see note below)
  * Ensure the webserver config on `docker\nginx.conf` is correct for your project. PHPDocker.io will have customised this file according to the application type you chose on the generator, for instance `web/app|app_dev.php` on a Symfony project, or `public/index.php` on generic apps.

Note: you may place the files elsewhere in your project. Make sure you modify the volume linking on `docker-compose.yml` for both the webserver and php-fpm so that the folder being shared into the container is the root of your project.
 
#How to run#

Dependencies:

  * Ensure you have the latest `docker engine` installed. Your distribution's package might be a little old, if you encounter problems, do upgrade. See https://docs.docker.com/engine/installation/
  * Ensure you have the latest `docker-compose` installed. See [docs.docker.com/compose/install](https://docs.docker.com/compose/install/)

Once you're done, simply `cd` to the folder where you placed the files, then `docker-compose up -d`. This will initialise and start all the containers, then leave them running in the background.

##Services exposed outside your environment##

You can access your application via **`localhost`**, if you're running the containers directly, or through **`{{ vmIpAddress }}`** when run on a vm. nginx and mailhog both respond to any hostname, in case you want to add your own hostname on your `/etc/hosts` 

Service|Address outside containers
------|---------|-----------
Webserver|[localhost:{{ webserverPort }}](http://localhost:{{ webserverPort }})
{% if mailhogContainerName %}Mailhog web interface|[localhost:{{ mailhogPort }}](http://localhost:{{ mailhogPort }}){{ "\n" }}{% endif %}

##Hosts within your environment##

You'll need to configure your application to use any services you enabled:

Service|ContainerName|Port number
------|---------|-----------
php-fpm|{{ phpFpmContainerName }}|9000
{% if mysqlContainerName %}MySQL|{{ mysqlContainerName }}|3306 (default){{ "\n" }}{% endif %}
{% if postgresContainerName %}Postgres|{{ postgresContainerName }}|5432 (default){{ "\n" }}{% endif %}
{% if memcachedContainerName %}Memcached|{{ memcachedContainerName }}|11211 (default){{ "\n" }}{% endif %}
{% if redisContainerName %}Redis|{{ redisContainerName }}|6379 (default){{ "\n" }}{% endif %}
{% if elasticsearchContainerName %}Elasticsearch|{{ elasticsearchContainerName }}|9200 (HTTP default) / 9300 (ES transport default){{ "\n" }}{% endif %}
{% if mailhogContainerName %}SMTP (Mailhog)|{{ mailhogContainerName }}|1025 (default){{ "\n" }}{% endif %}

#Docker compose cheatsheet#

**Note:** you need to cd first to where your docker-compose.yml file lives.

  * Start containers in the background: `docker-compose up -d`
  * Start containers on the foreground: `docker-compose up`. You will see a stream of logs for every container running.
  * Stop containers: `docker-compose stop`
  * Kill containers: `docker-compose kill`
  * View container logs: `docker-compose logs`
  * Execute command inside of container: `docker exec -it {{ phpFpmContainerName }} COMMAND` where `COMMAND` is whatever you want to run. For instance, `/bin/bash` to open a console prompt.
