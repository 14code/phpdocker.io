PHPDocker.io generated environment
==================================

#Add to your project#

  * Unzip the file.
  * Move the `phpdocker` folder into your project. You may rename this folder.
  * Ensure the webserver config on `docker\nginx.conf` is correct for your project. PHPDocker.io generates it either for a typical Symfony project (`web/app|app_dev.php`) or generic (`public/index.php`).

Note: you may place the files elsewhere in your project. Make sure you modify the volume linking on `docker-compose.yml` for both the webserver and php-fpm so that the folder being shared into the container is the root of your project.
 
#How to run#

You have two options to run the environment, depending mainly on your host OS. Essentially, you can either run the containers on bare metal, or through a virtualised environment.
 
##Linux##

If you run Linux, you have both choices available to you. Running directly has certain advantages, not least of which the fact there's essentially zero overhead and full access to your system's muscle.

The advantage of running through a virtualised environment is mainly having your whole environment neatly packed into a single set of files for the virtual machine.

The choice is up to you. If you'd rather run the containers directly:

  * Ensure you have the latest `docker engine` installed. Your distribution's package might be a little old, if you encounter problems, do upgrade. See https://docs.docker.com/engine/installation/
  * Ensure you have the latest `docker-compose` installed. See https://docs.docker.com/compose/install/
  
Once you're done, simply `cd` to the folder where you placed the files, then `docker-compose up -d`. This will initialise and start all the containers, then leave them running in the background.
  
##Other OS##

MacOS and Windows have no native support for docker containers. The way around this is to boot a minimal Linux virtual machine, then run the containers inside.

Whichever way to do this is entirely up to you, but PHPDocker.io already has you covered provided you have a recent version of [vagrant](https://www.vagrantup.com/) and [virtualbox](https://www.virtualbox.org/) installed.

Simply `cd` to the folder where you placed the files, then `vagrant up`. This will fire up [boot2docker](http://boot2docker.io/), then initialise the containers within. You can `vagrant ssh` to act on the containers from then on.

##Services exposed outside your environment##

#Hostname#

Either on **`localhost`**, if you're running the containers directly, or on **`{{ vmIpAddress }}`** when run on a vm. nginx and mailhog both respond to any hostname, in case you want to add your own hostname on your `/etc/hosts` 

#Webserver#

The webserver (`nginx`) is exposed through port **{{ webserverPort }}**
 
#Mailhog#

Web interface is exposed on port **{{ mailhogPort }}**.

##Hosts within your environment##

You'll need to configure your application to use any services you enabled:

Service|Hostname|Port number
------|---------|-----------
php-fpm|{{ phpFpmHostname }}|9000
{% if mysqlHostname %}MySQL|{{ mysqlHostname }}|3306 (default){{ "\n" }}{% endif %}
{% if memcachedHostname %}Memcached|{{ memcachedHostname }}|11211 (default){{ "\n" }}{% endif %}
{% if redisHostname %}Redis|{{ redisHostname }}|6379 (default){{ "\n" }}{% endif %}
{% if mailhogHostname %}SMTP (Mailhog)|{{ mailhogHostname }}|1025 (default){{ "\n" }}{% endif %}


#Docker compose cheatsheet#

  * Start containers in the background: `docker-compose up -d`
  * Start containers on the foreground: `docker-compose up`. You will see a stream of logs for every container running.
  * Stop containers: `docker-compose stop`
  * Kill containers: `docker-compose kill`
  * View container logs: `docker-compose logs`
  * Execute command inside of container: `docker exec -it {{ phpFpmHostname }} COMMAND` where `COMMAND` is whatever you want to run. For instance, `/bin/bash` to open a console prompt.

#Recommendations

  * If you run the containers through vagrant and use Symfony, or any framework that generates loads of cache/log files, make sure you configure your application so that cache and logs are written outside of your project root. If you selected "symfony app" on the form, you'll have folders available on the PHP container under `/tmp/{{ projectName }}`. This will dramatically improve the performance of your app since these files won't be shared over back to your host (your project folder is a network share). 
  * If you have a NFS server available on your host (Linux, Mac), use it. Change `Vagrantfile` so that each `synced_folder` has `, nfs: true` at the end. If you do, be advised you'll need admin mojo on your host as `vagrant up` will need permissions to modify your NFS shares.
  
